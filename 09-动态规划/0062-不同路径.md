https://leetcode.com/problems/unique-paths/description/

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


只能下移或者右移。


解法1：记忆化搜索，一气呵成！

```python
class Solution:

    def __init__(self):
        self.cached = None

    def _path(self, i, j):
        if self.cached[i][j] != 0:
            return self.cached[i][j]

        if i == 0 and j == 0:
            return 1
        path_ways = 0
        if i == 0:
            path_ways = self._path(0, j - 1)
        elif j == 0:
            path_ways = self._path(i - 1, 0)
        else:
            path_ways = self._path(i, j - 1) + self._path(i - 1, j)
        self.cached[i][j] = path_ways
        return path_ways

    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        self.cached = [[0 for _ in range(n)] for _ in range(m)]

        return self._path(m - 1, n - 1)
```

用测试用例得到的缓存数组：
[[0, 1, 1, 1], [1, 2, 3, 4], [1, 3, 6, 10], [1, 4, 10, 20], [1, 5, 15, 35]]


动态规划：
```python
class Solution:

    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """

        dp = [[0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 1

        for i in range(m):
            for j in range(n):
                if i == 0:
                    if j == 0:
                        continue
                    dp[0][j] = dp[0][j - 1]
                elif j == 0:

                    dp[i][0] = dp[i - 1][0]
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[- 1][- 1]
```

动态规划得到的 dp 数组：
[[1, 1, 1, 1], [1, 2, 3, 4], [1, 3, 6, 10], [1, 4, 10, 20], [1, 5, 15, 35]]


# 更好更节省内存的一种解法
## 我是如何想到的，把缓存数组抄一遍，或者自己把矩阵画出来，就能知道这个数组怎么来的。
## 每一行，只依赖上一行的结果，我们完全可以用一行来逐步更新
## 第 1 个元素肯定是 1
## 第 1 行元素肯定全是 1
## 有点背包问题的意思：节约了空间复杂度。
```python
class Solution:

    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        dp = [1] * n
        for i in range(1, m):
            for i in range(1, n):  # 从索引 2 开始走就行了
                dp[i] = dp[i] + dp[i - 1]
        return dp[-1]
```
怎么样，是不是很酷！